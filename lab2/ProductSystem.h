#pragma once
#include <iostream>
#include <string>
#include <vector>
#include <memory>
#include <sstream>

// === 1. Принцип ISP: Разделение интерфейсов ===
// Клиенты не должны зависеть от методов, которыми не пользуются.

// Интерфейс для товаров, которые могут включаться/выключаться
class IЭлектронныйТовар {
public:
    virtual ~IЭлектронныйТовар() = default;
    virtual void включить() const = 0;
    virtual void выключить() const = 0;
};

// Интерфейс для товаров с ограниченным сроком годности
class IПродовольственныйТовар {
public:
    virtual ~IПродовольственныйТовар() = default;
    virtual std::string проверитьСрокГодности() const = 0;
};

// === 2. Принцип LSP: Базовый класс (Супертип) ===
// Паттерн "Товар" должен быть абстрактным, чтобы подтипы могли его замещать.
class Товар {
protected:
    std::string наименование;
    double цена;
public:
    Товар(const std::string& н, double ц) : наименование(н), цена(ц) {}
    virtual ~Товар() = default;

    // Общая функциональность для всех подтипов (LSP)
    const std::string& получитьНаименование() const { return наименование; }
    double получитьЦену() const { return цена; }

    // Виртуальный метод для полиморфизма (LSP)
    virtual std::string получитьОписание() const = 0;

    // Абстракция для проверки готовности к продаже
    virtual bool готовКПродаже() const { return true; } 
};

// === 3. Конкретные классы-наследники (Подтипы) ===

class Молоко : public Товар, public IПродовольственныйТовар {
private:
    std::string датаИстечения;
public:
    Молоко(const std::string& н, double ц, const std::string& дата) 
        : Товар(н, ц), датаИстечения(дата) {}

    std::string проверитьСрокГодности() const override {
        return "Срок годности до: " + датаИстечения;
    }

    std::string получитьОписание() const override {
        return "Молоко: " + наименование + ". Цена: " + std::to_string(цена);
    }

    // Молоко не готово к продаже, если срок годности истёк (пример LSP: усиление предусловий)
    bool готовКПродаже() const override { 
        // В реальном приложении здесь будет логика сравнения дат.
        // Для примера: всегда готово.
        return true; 
    }
};

class Телевизор : public Товар, public IЭлектронныйТовар {
private:
    std::string состояние = "Выключен";
public:
    Телевизор(const std::string& н, double ц) : Товар(н, ц) {}

    void включить() const override {
        std::cout << "ТВ " << наименование << " включен." << std::endl;
    }
    void выключить() const override {
        std::cout << "ТВ " << наименование << " выключен." << std::endl;
    }
    
    std::string получитьОписание() const override {
        return "Телевизор: " + наименование + ". Цена: " + std::to_string(цена);
    }
};

class Игрушка : public Товар {
private:
    int возрастноеОграничение;
public:
    Игрушка(const std::string& н, double ц, int возраст) 
        : Товар(н, ц), возрастноеОграничение(возраст) {}

    std::string получитьОписание() const override {
        return "Игрушка: " + наименование + ". Возраст: " + std::to_string(возрастноеОграничение) + "+. Цена: " + std::to_string(цена);
    }
};


// === 4. Принцип DIP: Модуль Высокого Уровня (Менеджер) ===
// Зависит от абстракции (класса Товар), а не от конкретных деталей.
class МенеджерМагазина {
public:
    // Работает со всеми подтипами через базовый класс Товар (LSP/DIP)
    void инвентаризация(const std::vector<std::unique_ptr<Товар>>& товары) const {
        std::cout << "\n--- Инвентаризация (Менеджер) ---" << std::endl;
        for (const auto& товар : товары) {
            std::cout << "Товар: " << товар->получитьНаименование() 
                      << " | Описание: " << товар->получитьОписание() << std::endl;
            
            // Проверка, что товар готов к продаже (LSP)
            if (!товар->готовКПродаже()) {
                std::cout << "[ВНИМАНИЕ] Товар " << товар->получитьНаименование() << " не готов к продаже!" << std::endl;
            }
        }
    }
};